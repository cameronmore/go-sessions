package env

// This test file was generated by AI (Google Gemini Flash 2.5, in July 2025)

import (
	"reflect"
	"testing"
)

func Test_lex(t *testing.T) {
	tests := []struct {
		name    string
		envData []byte
		want    []token
		wantErr bool
	}{
		{
			name:    "simple key-value pair",
			envData: []byte("KEY=value"),
			want: []token{
				{Value: 'K', tokenType: character},
				{Value: 'E', tokenType: character},
				{Value: 'Y', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: 'a', tokenType: character},
				{Value: 'l', tokenType: character},
				{Value: 'u', tokenType: character},
				{Value: 'e', tokenType: character},
				{tokenType: eof},
			},
			wantErr: false,
		},
		{
			name:    "empty data",
			envData: []byte(""),
			want:    []token{{tokenType: eof}},
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := lex(tt.envData)
			if (err != nil) != tt.wantErr {
				t.Errorf("lex() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("lex() got = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_parse(t *testing.T) {
	tests := []struct {
		name    string
		tokens  []token
		want    map[string]string
		wantErr bool
	}{
		{
			name: "single key-value pair",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{Value: 'E', tokenType: character},
				{Value: 'Y', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: 'a', tokenType: character},
				{Value: 'l', tokenType: character},
				{Value: 'u', tokenType: character},
				{Value: 'e', tokenType: character},
				{tokenType: eof},
			},
			want:    map[string]string{"KEY": "value"},
			wantErr: false,
		},
		{
			name: "multiple key-value pairs with newlines",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{Value: '1', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: '1', tokenType: character},
				{tokenType: newline},
				{Value: 'K', tokenType: character},
				{Value: '2', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: '2', tokenType: character},
				{tokenType: eof},
			},
			want:    map[string]string{"K1": "v1", "K2": "v2"},
			wantErr: false,
		},

		{
			name: "value with spaces (invalid case as per package comment)",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{Value: 'E', tokenType: character},
				{Value: 'Y', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: 'a', tokenType: character},
				{tokenType: whitespace},
				{Value: 'u', tokenType: character},
				{Value: 'e', tokenType: character},
				{tokenType: eof},
			},
			want:    map[string]string{}, // current implementation includes whitespace in value
			wantErr: true,
		},
		{
			name: "line with comment",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{Value: 'E', tokenType: character},
				{Value: 'Y', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{Value: 'a', tokenType: character},
				{Value: 'l', tokenType: character},
				{Value: 'u', tokenType: character},
				{Value: 'e', tokenType: character},
				{tokenType: comment},
				{Value: 'c', tokenType: character},
				{Value: 'o', tokenType: character},
				{tokenType: newline},
				{tokenType: eof},
			},
			want:    map[string]string{"KEY": "value"},
			wantErr: false,
		},
		{
			name: "empty tokens",
			tokens: []token{
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: false,
		},
		{
			name: "only newline",
			tokens: []token{
				{tokenType: newline},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: false,
		},
		{
			name: "missing key",
			tokens: []token{
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: true,
		},
		{
			name: "missing value",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{tokenType: assignment},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: true,
		},
		{
			name: "multiple assignments in one line",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{tokenType: assignment},
				{Value: 'v', tokenType: character},
				{tokenType: assignment},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: true,
		},
		{
			name: "key without value, followed by newline",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{tokenType: newline},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: false, // This is fine as it's just a "key" with no assignment, so it's ignored
		},
		{
			name: "key and assignment without value, followed by newline",
			tokens: []token{
				{Value: 'K', tokenType: character},
				{tokenType: assignment},
				{tokenType: newline},
				{tokenType: eof},
			},
			want:    map[string]string{},
			wantErr: true, // missing value
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := parse(tt.tokens)
			if (err != nil) != tt.wantErr {
				t.Errorf("parse() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("parse() got = %v, want %v", got, tt.want)
			}
		})
	}
}
